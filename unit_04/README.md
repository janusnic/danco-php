# danco-php

Проверка существования и размера файла<br>
используются две функции:<br>
file_exists( ) и is_file( ).
<br>
Функция filе_ехists ( ) проверяет, существует ли заданный файл. Если файл существует, функция возвращает TRUE, в противном случае возвращается FALSE. <br>Синтаксис функции file_exists( ):
bool file_exists(string файл)
<br>Пример проверки существования файла:
<pre>
if (! file_exists ($filename)) :
print "File $filename does not exist!";
endif:
</pre>
1 is_file( )<br>
Функция is_file( ) проверяет существование заданного файла и возможность выполнения с ним операций чтения/записи. В сущности, is_file( ) представляет собой более надежную версию file_exists( ), которая проверяет не только факт существования файла, но и то, поддерживает ли он чтение и запись данных:
bool is_file(string файл)<br>
<pre>
$file = "somefile.txt";
if (is_file($file)) :
print "The file $file is valid and exists!";
else :
print "The file $file does not exist or it is not a valid file!";
endif:
</pre>

2 filesize( )<br>
Функция filesize( ) возвращает размер (в байтах) файла с заданным именем или FALSE в случае ошибки. Синтаксис функции filesize( ):
int filesize(string имя_файла)<br>
Предположим, вы хотите определить размер файла pastry.txt. Для получения нужной информации можно воспользоваться функцией filesize( ):<br>
$fs = filesize("pastry.txt"); print "Pastry.txt is $fs bytes.";
<br>Прежде чем выполнять операции с файлом, необходимо открыть его и связать с файловым манипулятором, а после завершения работы с файлом его следует закрыть. 
<br>Открытие и закрытие файлов
<br>Прежде чем выполнять операции ввода/вывода с файлом, необходимо открыть его функцией fopen( ).
<br>3 fopen( )<br>
Функция fopen( ) открывает файл (если он существует) и возвращает целое число -- так называемый файловый манипулятор (file handle). Синтаксис функции fopen( ):
int fopen (string файл, string режим [, int включение_пути])<br>
Открываемый файл может находиться в локальной файловой системе, существовать в виде стандартного потока ввода/вывода или представлять файл в удаленной системе, принимаемой средствами HTTP или FTP.<br>
Параметр файл может задаваться в нескольких формах, перечисленных ниже:
Если параметр содержит имя локального файла, функция fopen( ) открывает этот файл и возвращает манипулятор.<br>
Если параметр задан в виде php://stdin, php://stdout или php://stderr, открывается соответствующий стандартный поток ввода/вывода.<br>
Если параметр начинается с префикса http://, функция открывает подключение HTTP к серверу и возвращает манипулятор для указанного файла.<br>
Если параметр начинается с префикса ftp://, функция открывает подключение FTP к серверу и возвращает манипулятор для указанного файла. В этом случае следует обратить особое внимание на два обстоятельства: если сервер не поддерживает пассивный режим FTP, вызов fopen( ) завершается неудачей. Более того, FTP-файлы открываются либо для чтения, либо для записи.<br>
При работе в пассивном режиме сервер ЯР ожидает подключения со стороны клиентов. При работе в активном режиме сервер сам устанавливает соединение с клиентом. По умолчанию обычно используется активный режим.<br>


Режимы открытия файла<br>

r
Только чтение. Указатель текущей позиции устанавливается в начало файла<br>
r+
Чтение и запись. Указатель текущей позиции устанавливается в начало файла<br>
w
Только запись. Указатель текущей позиции устанавливается в начало файла, а все содержимое файла уничтожается. Если файл не существует, функция пытается создать его<br>
w+
Чтение и запись. Указатель текущей позиции устанавливается в начало файла, а все содержимое файла уничтожается. Если файл не существует, функция пытается создать его <br>
a
Только запись. Указатель текущей позиции устанавливается в конец файла. Если файл не существует, функция пытается создать его<br>
a+
Чтение и запись. Указатель текущей позиции устанавливается в конец файла. Если файл не существует, функция пытается создать его<br>
Если необязательный третий параметр включение_пути равен 1, то путь к файлу определяется по отношению к каталогу включаемых файлов, указанному в файле php.ini <br>
Ниже приведен пример открытия файла функцией fopen( ). Вызов die( ), используемый в сочетании с fopen( ), обеспечивает вывод сообщения об ошибке в том случае, если открыть файл не удастся:<br>
<pre>
$file = "userdata.txt"; // Некоторый файл
$fh = fopen($file, "a+") or die("File ($file) does not exist!");
</pre>
Следующий фрагмент открывает подключение к сайту PHP (http://www.php.net):
<pre>
$site = "http://www.php.net": // Сервер, доступный через HTTP
$sh = fopen($site., "r"); //Связать манипулятор с индексной страницей Php.net
</pre>
После завершения работы файл всегда следует закрывать функцией fclose( ).
<br>3 fclose ( )
<br>Функция fclose( ) закрывает файл с заданным манипулятором. При успешном закрытии возвращается TRUE, при неудаче -- FALSE. Синтаксис функции fclose( ):
int fclose(int манипулятор)<br>
Функция fclose( ) успешно закрывает только те файлы, которые были ранее открыты функциями fopen( ) или fsockopen( ). <br>Пример закрытия файла:
<pre>
$file = "userdata.txt";
if (file_exists($file)) :
$fh = fopen($file, "r");
// Выполнить операции с файлом
fclose($fh);
else :
print "File Sfile does not exist!";
endif;

</pre>
4  Запись в файл
<br>С открытыми файлами выполняются две основные операции -- чтение и запись.
is_writeable( )
<br>Функция is_writeable( ) позволяет убедиться в том, что файл существует и для него разрешена операция записи. Возможность записи проверяется как для файла, так и для каталога. Синтаксис функции is_writeable( ):
bool is_writeable (string файл)
<br>Одно важное обстоятельство: скорее всего, PHP будет работать под идентификатором пользователя, используемым web-сервером (как правило, «nobody»). Пример использования is_writeable( ) приведен в описании функции fwrite( ).
fwrite ( )
<br>Функция fwrite( ) записывает содержимое строковой переменной в файл, заданный файловым манипулятором. Синтаксис функции fwrite( ):
int fwrite(int манипулятор, string переменная [, int длина])
<br>Если при вызове функции передается необязательный параметр длина, запись останавливается либо после записи указанного количества символов, либо при достижении конца строки. Проверка возможности записи в файл продемонстрирована в следующем примере:
<pre>
&lt;?
// Информация о трафике на пользовательском сайте
$data = "08:13:00|12:37:12|208.247.106.187|Win98";
$filename = "somefile.txt";
// Если файл существует и в него возможна запись
if ( is_writeable($filename) ) :
// Открыть файл и установить указатель текущей позиции в конец файла
$fh = fopen($filename, "a+");
// Записать содержимое $data в файл
$ success - fwrite($fh, $data);
// Закрыть файл
fclose($fh); else :
print "Could not open Sfilename for writing";
endif;
?&gt;
</pre>
Функция fputs( ) является псевдонимом fwrite( ) и может использоваться всюду, где используется fwrite( ).
fputs( )
<br>Функция fputs( ) является псевдонимом fwrite( ) и имеет точно такой же синтаксис. Синтаксис функции fputs( ):
int fputs(int манипулятор, string переменная [, int длина])
<br>5 Чтение из файла
Несомненно, чтение является самой главной операцией, выполняемой с файлами. Ниже описаны некоторые функции, повышающие эффективность чтения из файла. Синтаксис этих функций практически точно копирует синтаксис аналогичных функций записи.
is_readable( )
<br>Функция is_readable( ) позволяет убедиться в том, что файл существует и для него разрешена операция чтения. Возможность чтения проверяется как для файла, так и для каталога. Синтаксис функции is_readable( ):
bool is_readable (string файл]
<br>Скорее всего, PHP будет работать под идентификатором пользователя, используемым web-сервером (как правило, «nobody»), поэтому для того чтобы функция is_readable( ) возвращала TRUE, чтение из файла должно быть разрешено всем желающим. Следующий пример показывает, как убедиться в том, что файл существует и доступен для чтения:
<pre>
if ( is_readable($filename) ) :
// Открыть файл и установить указатель текущей позиции в конец файла
$fh = fopen($filename, "r");
else :
print "$filename is not readable!";
endif;
</pre>
5 fread( )
<br>Функция fread( ) читает из файла, заданного файловым манипулятором, заданное количество байт. Синтаксис функции fwrite( ):
int fread(int манипулятор, int длина)
<br>Манипулятор должен ссылаться на открытый файл, доступный для чтения (см. описание функции is_readable( )). Чтение прекращается после прочтения заданного количества байт или при достижении конца файла. Рассмотрим текстовый файл pastry.txt. Чтение и вывод этого файла в браузере осуществляется следующим фрагментом:
<pre>
$fh = fopen('pastry.txt', "r") or die("Can't open file!");
$file = fread($fh, filesize($fh));
print $file;
fclose($fh);
</pre>
Используя функцию fllesize( ) для определения размера pastry.txt в байтах, вы гарантируете, что функция fread( ) прочитает все содержимое файла.
<pre>
Листинг 1. Текстовый файл pastry.txt
Recipe: Pastry Dough
1 1/4 cups all-purpose flour
3/4 stick (6 tablespoons) unsalted butter, chopped
2 tablespoons vegetable shortening 1/4 teaspoon salt
3 tablespoons water
6 fgetc( )
</pre>
Функция fgetc( ) возвращает строку, содержащую один символ из файла в текущей позиции указателя, или FALSE при достижении конца файла. Синтаксис функции fgetc( ):
string fgetc (int манипулятор)<br>
Манипулятор должен ссылаться на открытый файл, доступный для чтения. В следующем примере продемонстрированы посимвольное чтение и вывод файла с использованием функции fgetc( ):
<pre>
$fh = fopen("pastry.txt", "r"); while (! feof($fh)) :
$char = fgetc($fh):
print $char; endwhile;
fclose($fh);
</pre>
7 fgets( )
<br>Функция fgets( ) возвращает строку, прочитанную от текущей позиции указателя в файле, определяемом файловым манипулятором. Файловый указатель должен ссылаться на открытый файл, доступный для чтения. Синтаксис функции fgets( ):
string fgets (int манипулятор, int длина)<br>
Чтение прекращается при выполнении одного из следующих условий:<br>
из файла прочитано длина -- 1 байт;<br>
из файла прочитан символ новой строки (включается в возвращаемую строку);<br>
из файла прочитан признак конца файла (EOF).<br>
Если вы хотите организовать построчное чтение файла, передайте во втором параметре значение, заведомо превышающее количество байт в строке. Пример построчного чтения и вывода файла:<br>
<pre>
$fh = fopen("pastry.txt", "r");
while (! feof($fh));
$line = fgets($fh, 4096);
print $line. "&lt;br&gt;";
endwhile;
fclose($fh):
</pre>
8 fgetss( )
<br>Функция fgetss( ) полностью аналогична fgets( ) за одним исключением -- она пытается удалять из прочитанного текста все теги HTML и PHP:
string fgetss (Int манипулятор, int длина [, string разрешенные_теги])
<pre>
Листинг 8.1. Файл science.html
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Breaking News - Science&lt;/title&gt;
&lt;body&gt;
&lt;h1&gt;Alien lifeform discovered&lt;/h1&gt;&lt;br&gt;
&lt;b&gt;August 20. 2000&lt;/b&gt;&lt;br&gt;
Early this morning, a strange new form of fungus was found growing in the closet of W. J. Gilmore's old apartment refrigerator. It is not known if powerful radiation emanating from the tenant's computer monitor aided in this evolution.
&lt;/body&gt;
&lt;/html&gt;
</pre>
Листинг 8.2. Удаление тегов из файла HTML перед отображением в браузере
<pre>
&lt;?
$fh = fopen("science.html", "r");
while (! feof($fh)) :
print fgetss($fh, 2048);
endwhile;
fclose($fh);
?&gt;
</pre>

Листинг 9.1. Выборочное удаление тегов из файла HTML
<pre>
&lt;?
$fh = fopenC'science.html", "r");
$allowable = "&lt;br&gt;";
while (! feof($fh)) :
print fgetss($fh. 2048, $allowable);
endwhile;
fclose($fh);
?&gt;
</pre>
10 Чтение файла в массив
<br>Функция file( ) загружает все содержимое файла в индексируемый массив. Каждый элемент массива соответствует одной строке файла. Синтаксис функции filе ( ):
array file (string файл [, int включение_пути])
<br>Если необязательный третий параметр включение_пути равен 1, то путь к файлу определяется по отношению к каталогу включаемых файлов, указанному в файле php.ini. 
<br>
Листинг 10.1. Загрузка файла pastry.txt функцией file( )
<pre>
&lt;?
$file_array = file( "pastry.txt" );
while ( list( $line_num, $line ) = each($file_array ) ):
print "&lt;b&gt;Line $line_num:&lt;/b&gt; ". htmlspecialchars($line )."&lt;br&gt;\n"
endwhile;
?&gt;
</pre>

11 Перенаправление файла в стандартный выходной поток
<br>Функция readfile( ) читает содержимое файла и направляет его в стандартный вывод (в большинстве случаев -- в браузер). Синтаксис функции readfile( ):
int readfile (string файл [, int включение_пути])
<br>Функция возвращает количество прочитанных байтов. Файл может находиться в локальной файловой системе, существовать в виде стандартного потока ввода/вывода или представлять файл в удаленной системе, принимаемой средствами HTTP или FTP. Параметр файл задается по тем же правилам, что и в функции fopen( ).
<br>Предположим, у вас имеется файл latorre.txt, содержимое которого вы хотите вывести в браузере:
Restaurant "La Тоrrе." located in Nettuno, Italy, offers an eclectic blend of style. history, and fine seafood cuisine. Within the walls of the medieval borgo surrounding the city, one can dine while watching the passersby shop in the village boutiques. Comfort coupled with only the freshest seafare make La Torre one of Italy's finest restaurants.
<br>При выполнении следующего фрагмента все содержимое latorre.txt направляется в стандартный выходной поток:
<pre>
&lt;?
$restaurant_file = "latorre.txt";
// Направить весь файл в стандартный выходной поток
readfile($restaurant_filе);
?&gt;
</pre>
12 Открытие файлового манипулятора процесса
<br>popen( )
<br>Наряду с обычными файлами можно открывать файловые манипуляторы для взаимодействия с процессами на сервере. Задача решается функцией рореn( ), которая имеет следующий синтаксис:
int popen (string команда, string режим)
<br>Параметр команда определяет выполняемую системную команду, а параметр режим описывает режим доступа:
<pre>
&lt;?
// Открыть файл "spices.txt" для записи
$fh = fopen("spices.txt","w");
// Добавить несколько строк текста
fputs($fh, "Parsley, sage, rosemary\n");
fputs($fh, "Paprika, salt, pepper\n");
fputs($fh, "Basil, sage, ginger\n");
// Закрыть манипулятор
fclose($fh);
// Открыть процесс UNIX grep для поиска слова Basil в файле spices.txt
$fh - popen("grep Basil &lt; spices.txt", "r");
// Вывести результат работы grep
fpassthru($fh);
?&gt;
</pre>

Функция fpassthru( ) является аналогом функции passthru( ), рассматриваемой в разделе «Запуск внешних программ» этой главы.
<br>pclose( )
<br>После выполнения всех операций файл или процесс необходимо закрыть. Функция pclose( ) закрывает соединение с процессом, заданным манипулятором, по аналогии с тем, как функция fclose( ) закрывает файл, открытый функцией fopen( ). Синтаксис функции pclose( ):
int pclose (int манипулятор}
<br>В параметре манипулятор передается манипулятор, полученный ранее при успешном вызове рореn( ).
<br>13 Открытие соединения через сокет
<br>PHP не ограничивается взаимодействием с файлами и процессами -- вы также можете устанавливать соединения через сокеты. Сокет (socket) представляет собой программную абстракцию, позволяющую устанавливать связь с различными службами другого компьютера.
<br>fsockopen( )
Функция fsockopen( ) устанавливает сокетное соединение с сервером в Интернете
через протокол TCP или UDP. Синтаксис функции fsockopen( ):
int fsockopen (string узел, int порт [, int код_ошибки [, string текст_ошибки [, int тайм-аут]]])
<br>Необязательные параметры код_ошибки и текст_ошибки содержат информацию, которая будет выводиться в случае неудачи при подключении к серверу. Оба параметра должны передаваться по ссылке. Третий необязательный параметр, тайм-аут, задает продолжительность ожидания ответа от сервера (в секундах). <br>
UDP (User Datagram Protocol) -- коммуникационный протокол, не ориентированный на соединение.<br>
socket_set_blocking( )
<br>Функция socket_set_b1ocki ng( ) позволяет установить контроль над тайм-аутом для операций с сервером:
socket_set_blocking(int манипулятор, boolean режим)
<br>Параметр манипулятор задает открытый ранее сокет, а параметр режим выбирает режим, в который переключается сокет (TRUE для блокирующего режима, FALSE для неблокирующего режима). Пример использования функций fsockopen( ) и socket_set_blocking( ).
<br>Листинг 13.1. Использование функции fsockopen() для получения информации о сервере
<pre>
&lt;?
function getthehost($host,$path) { 
	// Открыть подключение к узлу 
	$fp = fsockopen($host, 80); 
	// Перейти в блокирующий режим 
	socket_set_blocking($fp, 1); 
	// Отправить заголовки 
	fputs($fp,"GET $path HTTP/1.1\r\n"); 
	fputs ($fp, "Host: $host\r\n\r\n"); 
	$x = 1; 
	// Получить заголовки 
	while($x &lt; 10): 
		$headers = fgets ($fp, 4096); 
		print $headers; 
		$x++; 
	endwhile; 
	// Закрыть манипулятор 
	fclose($fp); 
	} 
getthehost("www.ukr.net", "/");
<br>
В результате выполнения листинга выводится следующий результат:
HTTP/1.1 200 OK Server: nginx Date: Sat, 14 Feb 2015 18:33:13 GMT Content-Type: text/html Content-Length: 362 Last-Modified: Wed, 12 Jun 2013 11:52:20 GMT Connection: close ETag: "51b860f4-16a" Set-Cookie: uid=1CpM/VTflOkaxn3YBIVxAg==; expires=Sun, 14-Feb-16 18:33:13 GMT; domain=.ukr.net; path=/
<br>pfsockopen( )
<br>Функция pfsockopen( ) представляет собой устойчивую (persistent) версию fsockopen( ). Это означает, что соединение не будет автоматически разорвано по завершении сценария, в котором была вызвана функция. Синтаксис функции pfsockopen( ):
int pfsockopen (string узел, int порт [, int код_ошибки [, string текст _ошибки [, int тайм-аут]]])
<br>В зависимости от конкретных целей вашего приложения может оказаться удобнее использовать pfsockopen( ) вместо fsockopen( ).
<br>
14 Запуск внешних программ
<br>Сценарии PHP также могут выполнять программы, находящиеся на сервере. Такая возможность особенно часто используется при администрировании системы через web-браузер, а также для более удобного получения сводной информации о системе.
ехес( )
<br>Функция ехес( ) запускает заданную программу и возвращает последнюю строку ее выходных данных. Синтаксис функции ехес( ):
string exec (string команда [, string массив [, int возврат]])
<br>Обратите внимание: функция ехес( ) только выполняет команду, не выводя результатов ее работы. Все выходные данные команды можно сохранить в необязательном параметре массив. Кроме того, если при заданном параметре массив также задается переменная возврат, последней присваивается код возврата выполненной команды.
<br>Листинг показывает, как использовать функцию ехес( ) для выполнения системной функции UNIX ping.
<br>Листинг 14. Проверка связи с сервером с применением функции ехес( )
<pre>
&lt;?php 

exec("ping -c 5 www.php.net", $ping); 
// В Windows - exec("ping -n 5 www.php.net. $ping); 

for ($i=0; $i&lt; count($ping);$i++): 
	print "&lt;br&gt;$ping[$i]"; 
endfor;
PING php-web2.php.net (72.52.91.14) 56(84) bytes of data.

--- php-web2.php.net ping statistics ---
5 packets transmitted, 0 received, 100% packet loss, time 4032ms
</pre>
Обратные апострофы<br>
Существует и другой способ выполнения системных команд, не требующий вызова функций, -- выполняемая команда заключается в обратные апострофы (` `), а результаты ее работы отображаются в браузере. Пример:
<pre>
$output = `ls`;
print "&lt;pre&gt;$output&lt;/pre&gt;";
</pre>
Этот фрагмент выводит в браузер содержимое каталога, в котором находится сценарий.
Внутренний параметр ping -с 5 (-п 5 в системе Windows) задает количество опросов сервера.<br>
Если вы хотите просто вернуть неформатированные результаты выполнения команды, воспользуйтесь функцией passthru( ), описанной ниже.<br>
passthru( )<br>
Функция passthru( ) работает почти так же, как ехес( ), за одним исключением -- она автоматически выводит результаты выполнения команды. Синтаксис функции passthru( ):
<pre>
void passthru(string команда [, int возврат])
</pre>
Если при вызове passthru( ) передается необязательный параметр возврат, этой переменной присваивается код возврата выполненной команды.
<br>escapeshellcmd( )
<br>Функция escapeshellcmd( ) экранирует все потенциально опасные символы, которые могут быть введены пользователем (например, на форме HTML), для выполнения команд exec( ), passthru( ), system( ) или рореn( ). Синтаксис:
string escapeshellcmd (string команда)
<br>К пользовательскому вводу всегда следует относиться с определенной долей осторожности, но даже в этом случае пользователи могут вводить команды, которые будут исполняться функциями запуска системных команд. Рассмотрим следующий фрагмент:
<pre>
$user_input = `rm -rf *`; // Удалить родительский каталог и все его подкаталоги
ехес($user_input); // Выполнить $user_input !!!
</pre>
Если не предпринять никаких мер предосторожности, такая команда приведет к катастрофе. Впрочем, можно воспользоваться функций escapeshellcmd( ) для экранирования пользовательского ввода:
<pre>
$user_input = `rm - rf *`; // Удалить родительский каталог и все его подкаталоги
ехес( escapeshellcmd($user_input)); // Экранировать опасные символы
</pre>
Функция escapeshellcmd( ) экранирует символ *, предотвращая катастрофические последствия выполнения команды.
<br>Безопасность является одним из важнейших аспектов программирования в среде Web, поэтому я посвятил целую главу этой теме и ее отношению к программированию PHP. За дополнительной информацией обращайтесь к главе 16.
<br>15  Работа с файловой системой
В PHP существуют функции для просмотра и выполнения различных операций с файлами на сервере. Информация об атрибутах серверных файлов (местонахождение, владелец и привилегии) часто бывает полезной.
<br>basename( )
<br>Функция basename( ) выделяет имя файла из переданного полного имени. Синтаксис функции basename( ):
string basename(string полное_имя)
<br>Выделение базового имени файла из полного имени происходит следующим образом:
$path = "/usr/local/phppower/htdocs/index.php"; $file = basename($path); // $file = "index.php"
<br>Фактически эта функция удаляет из полного имени путь и оставляет только имя файла.
<br>getlastmod( )
<br>Функция getlastmod( ) возвращает дату и время последней модификации страницы, из которой вызывается функция. Синтаксис функции getlastmod( ):
<br>int getlastmod(void)
<br>Возвращаемое значение соответствует формату даты/времени UNIX, и для его форматирования можно воспользоваться функцией date( ). Следующий фрагмент выводит дату последней модификации страницы:
<pre>
echo "Last modified: ".date( "H:i:s a". getlastmod( ) );
</pre>
stat( )
<br>
Функция stat( ) возвращает индексируемый массив с подробной информацией о файле с заданным именем:
array stat(string имя_файла)
<br>В элементах массива возвращается следующая информация:
<pre>
0 У стройство
1 Индексный узел (inode)
2 Режим защиты индексного узла
3 Количество ссылок
4 Идентификатор пользователя владельца
5 Идентификатор группы владельца
6 Тип устройства индексного узла
7 Размер в байтах
8 Время последнего обращения
9 Время последней модификации
10 Время последнего изменения
11 Размер блока при вводе/выводе в файловой системе
12 Количество выделенных блоков
</pre>
Таким образом, если вы хотите узнать время последнего обращения к файлу, обратитесь к элементу 8 возвращаемого массива. 
<br>
16 Рассмотрим пример:
<pre>
$file = "datafile.txt";
list($dev, $inode, $inodep, $nlink, $uid, $gid, $inodev, $size, $atime, $mtime, $ctime,
$bsize) = stat($file);
print "$file is $size bytes. &lt;br&gt;";
print "Last access time: $atime &lt;br&gt;";
print "Last modification time: $mtime &lt;br&gt;";
</pre>

17 Отображение и изменение характеристик файлов
<br>У каждого файла в системах семейства UNIX есть три важные характеристики:
<pre>
принадлежность группе;
владелец;
разрешения (permissions).
</pre>
Все эти характеристики можно изменить при помощи соответствующих функций PHP. Функции, описанные в этом разделе, не работают в системах семейства Windows.
Если у вас нет опыта работы в операционных системах UNIX, информацию о характеристиках файловой системы UNIX можно получить по адресуhttp://sunsite.auc.dk/linux-newbie/FAQ2.htm . 
<br>
chgrp( )
<br>Функция chgrp( ) пытается сменить группу, которой принадлежит заданный файл. Синтаксис функции chgrp( ):
int chgrp (string имя_файла, mixed группа)
<br>filegroup( )
Функция filegroup( ) возвращает идентификатор группы владельца файла с заданным именем или FALSE в случае ошибки. Синтаксис функции filegroup( ):
int filegroup (string имя_файла)
<br>chmod( )
<br>Функция chmod( ) изменяет разрешения файла с заданным именем. Синтаксис функции chmod( ):
<br>int chmod (string имя_файла, int разрешения)
<br>Разрешения задаются в восьмеричной системе. Специфика задания параметра функции chmod ( ) продемонстрирована в следующем примере:
<pre>
chmod("data_file.txt", g+r); // He работает
chmod("data_file.txt", 766); // Не работает
chmod("data_file.txt", 0766); // Работает
</pre>
fileperms( )

<br>Функция fileperms( ) возвращает разрешения файла с заданным именем или FALSE в случае ошибки. Синтаксис функции fileperms( ):
int fileperms (string имя_файла)
<br>chown( )
<br>Функция chown( ) пытается сменить владельца файла. Право изменения владельца файла предоставляется только привилегированному пользователю. Синтаксис функции <br>chown( ):
int chown (string имя_файла, mixed пользователь)
<br>fileowner( )
<br>Функция fileowner( ) возвращает идентификатор пользователя для владельца файла с заданным именем. Синтаксис функции fileowner( ):
<br>int fileowner (string имя_файла)
<br>18 Копирование и переименование файлов
<br>К числу других полезных системных функций, которые могут выполняться в сценариях PHP, относятся копирование и переименование файлов на сервере. Эти операции выполняются двумя функциями: сору( ) и rename( ).
<br>сору( )
Скопировать файл в сценарии PHP ничуть не сложнее, чем при помощи команды UNIX ср. Задача решается функцией PHP сору( ). Синтаксис функции сору( ):
int copy (string источник, string приемник)
<br>Функция сору( ) пытается скопировать файл источник в файл приемник; в случае успеха возвращается TRUE, а при неудаче -- FALSE. Если файл приемник не существует, функция сору( ) создает его. Следующий пример показывает, как создать резервную копию файла при помощи функции сору( ):
<pre>
$data_file = "datal.txt";
copy($data_file. $data_file'.bak') or die("Could not copy $data_file");
</pre>
rename ( )
Функция rename( ) переименовывает файл. В случае успеха возвращается TRUE, a при неудаче -- FALSE. Синтаксис функции rename( ):
<br>bool rename (string старое_имя, string новое_имя)
<br>Пример переименования файла функцией rename( ):
<pre>
$data_file = "datal.txt";
rename($data file, $datafile'.old') or die ("Could not rename $data file");
</pre>
19 Удаление файлов
<br>unlink( )
Функция unlink( ) удаляет файл с заданным именем. Синтаксис:
int unlink (string файл)
<br>Если вы работаете с PHP в системе Windows, при использовании этой функции иногда возникают проблемы. В этом случае можно воспользоваться описанной выше функцией system( ) и удалить файл командой DOS del:
<br>
system ("del filename.txt");<br>
20 Работа с каталогами<br>
Функции PHP позволяют просматривать содержимое каталогов и перемещаться по ним. 
<pre>
Типичная структура каталогов
drwxr-xr-x 4 root wheel 512 Aug 13 13:51 book/
drwxr-xr-x 4 root wheel 512 Aug 13 13:51 code/
-rw-r--r-- 1 root wheel 115 Aug 4 09:53 index.html
drwxr-xr-x 7 root wheel 1024 Jun 29 13:03 manual/
-rw-r--r-- 1 root wheel 19 Aug 12 12:15 test.php
</pre>
dirname( )
<br>Функция dirname( ) дополняет basename( ) -- она извлекает путь из полного имени файла. Синтаксис функции dirname( ):
string dirname (string путь)
<br>Пример использования dirname( ) для извлечения пути из полного имени:
<pre>
$path = "/usr/locla/phppower/htdocs/index.php";
$file = dirname($path); // $file = "usr/local/phppower/htdocs"
</pre>
Функция dirname( ) иногда используется в сочетании с переменной $SCRIPT_FILENAME для получения полного пути к сценарию, из которого выполняется команда:
<br>$dir - dirname($SCRIPT_FILENAME);
<br>is_dir( )
<br>Функция is_dir( ) проверяет, является ли файл с заданным именем каталогом:
<br>bool is_dir (string имя_файла)
<br>
<pre>
$ isdir = is_dir("index.html"); // Возвращает FALSE
$isdir = is_dir("book");  // Возвращает TRUE
</pre>
mkdir()
<br>Функция mkdir( ) делает то же, что и одноименная команда UNIX, -- она создает новый каталог. Синтаксис функции mkdir( ):
<br>int mkdir (string путь, int режим)
<br>Параметр путь определяет путь для создания нового каталога. Не забудьте завершить параметр именем нового каталога! Параметр режим определяет разрешения, назначаемые созданному каталогу.
<br>opendir( )
<br>Подобно тому как функция fopen( ) открывает манипулятор для работы с заданным файлом, функция opendir( ) открывает манипулятор для работы с каталогом. <br>Синтаксис функции opendir( ):
<br>
int opendir (string путь)<br>
closedir( )<br>
Функция closedir( ) закрывает манипулятор каталога, переданный в качестве параметра. Синтаксис функции closedir( ):<br>
void closedir(int манипулятор_каталога)<br>
readdir( )<br>
Функция readdir( ) возвращает очередной элемент заданного каталога. Синтаксис:
string readdir(int манипулятор_каталога)<br>
С помощью этой функции можно легко вывести список всех файлов и подкаталогов, находящихся в текущем каталоге:<br>
21.php
<pre>
$dh = opendir(' . );
while ($file = readdir($dh)) :
print "$file &lt;br&gt;"; endwhile;
closedir($dh);
chdir( )
</pre>
Функция chdir( ) работает так же, как команда UNIX cd, -- она осуществляет переход в каталог, заданный параметром. Синтаксис функции chdir( ):
int chdir (string каталог)<br>
В следующем примере мы переходим в подкаталог book/ и выводим его содержимое:
<pre>
$newdir = "book";
chdir($newdir) or die("Could not change to directory ($newdir)"); $dh = opendir(' . ');
print "Files:";
while ($file = readdir($dh)) ;
print "$file &lt;br&gt;";
endwhile;
closedir($dh);
</pre>
rewinddir( )<br>
Функция rewlnddir( ) переводит указатель текущей позиции в начало каталога, открытого функцией opendir( ). Синтаксис функции rewinddir( ):<br>
void rewinddir (int нанипулятор_каталога)<br>
22 Проект 1: простой счетчик обращений<br>
Сценарий, представленный в этом разделе, подсчитывает количество обращений к странице, в которой он находится. 
<br>
1. Присвоить переменной $access имя файла, в котором будет храниться значение счетчика.<br>
2. Использовать функцию filе( ) для чтения содержимого $access в массив $visits. Префикс @ перед именем функции подавляет возможные ошибки (например, отсутствие файла с заданным именем).<br>
3. Присвоить переменной $current_visitors значение первого (и единственного) элемента массива $visits.<br>
4. Увеличить значение $current_visitors на 1.<br>
5. Открыть файл $access для записи и установить указатель текущей позиции в начало файла.<br>
6. Записать значение $current_visitors в файл $access.<br>
7. Закрыть манипулятор, ссылающийся на файл $access.<br>
Листинг 22  Простой счетчик обращений<br>
<pre>
&lt;?
// Сценарий: простой счетчик обращений
// Назначение: сохранение количества обращений в файле
$access = "hits.txt"; // Имя файла выбирается произвольно
$visits = @file($access); // Прочитать содержимое файла в масссив
$current_visitors = $visits[0]; // Извлечь первый (и единственный) элемент
++$current_visitors; // Увеличить счетчик обращений
$fh = fopen($access. "w"); // Открыть файл hits.txt и установить
// указатель текущей позиции в начало файла
@fwrite($fh, $current_visitors);// Записать новое значение счетчика
// в файл "hits.txt"
fclose($fh);  // Закрыть манипулятор файла "hits.txt"
?&gt;
</pre>
Проект 23: построение карты сайта<br>
Сценарий, приведенный в листинге строит карту сайта -- иерархическое изображение всех папок и файлов на сервере, начиная с заданного каталога. При вычислении отступов элементов, из которых состоит карта сайта, используются функции, определенные в этой и предыдущих главах. Прежде чем переходить к программе, просмотрите алгоритм, написанный на псевдокоде:<br>
1. Объявить служебные переменные для хранения родительского каталога, имени графического файла с изображением папки, названия страницы и флага серверной ОС (Windows или другая система).<br>
2. Объявить функцию display_directory( ), которая читает содержимое каталога и форматирует его для вывода в браузере.<br>
3. Построить путь к каталогу объединением имени, передаваемого в переменной $dir1, с $dir.<br>
4. Открыть каталог и прочитать его содержимое. Отформатировать имена каталога и файлов и вывести их в браузере.<br>
5. Если текущий файл является каталогом, рекурсивно вызвать функцию display_di rectory( ) и передать ей имя нового каталога для вывода. Вычислить отступ, используемый при форматировании вывода.<br>
Если файл не является каталогом, он форматируется для отображения в виде гиперссылки (а также вычисляется отступ, используемый при форматировании).<br>
Листинг 23. Программа sitemap.php<br>
<pre>
// Файл: sitemap.php
// Назначение: построение карты сайта
// Каталог, с которого начинается построение карты
$beg_path = "C:\Program FilesVApache Group\Apache\htdocs\phprecipes";
// Файл с графическим изображением папки.
// Путь должен задаваться Относительно* корневого каталога сервера Apache
$folder_location = "C:\My Documents\PHP for Programmers\FINAL CHPS\graphics\folder.gif";
// Текст в заголовке окна $page_name = "PHPRecipes SiteMap";
// В какой системе будет использоваться сценарий - Linux или Windows?
// (0 - Windows; 1 - Linux)
$usingjinux = 0;
// Функция: display_directory
// Назначение: чтение содержимого каталога, определяемого параметром
// $dir1, с последующим форматированием иерархии каталогов и файлов.
// Функция может вызываться рекурсивно.
function display_directory ($dir1, $folder_location, $using_linux, $init_depth) {
// Обновить путь
$dir.= $dir1;
Sdh = opendir($dir);
while($file = readdir($dh)) :
// Элементы каталогов "." и ".." не выводятся.
if ( ($file != ".") && ($file != "..") ) :
if ($using_linux == 0 ) :
$depth = explode("\\", $dir): else :
$depth = explode("/", $dir); endif ; $curtent_depth = sizeof( $depth);
// Построить путь по правилам используемой операционной системы. if ($using_linux == 0) :
$tab_depth = $current_deptn - $init_depth;
$file = $dir. "\\", $file; else :
$file = $dir. "/",$file; endif;
// Переменная $file содержит каталог? if ( is dir($file) ) :
$х = 0;
// Вычислить отступ
while ( $х &lt; ($tab_depth * 2) ) :
print "&nbsp;";
$х++; endwhile;
print "&lt;img src=\"$folder_location\" alt=\"[dir]\"&gt;
".basename($file)."&lt;br&gt;";
// Увеличить счетчик &nbsp;
// Рекурсивный вызов функции display_directory()
display_directory($file, $folder_location, $using_linux, $init_depth);
// He каталог
else :
// Построить путь по правилам используемой
// операционной системы.
if ($using_linux == 0) :
$tab_depth = ($current_depth - $init_depth) - 2; $x = 0;
// Вычислить отступ
while ( $x &lt; (($tab_depth * 2) + 5) ) :
print "&nbsp;";
$x++;
endwhile:
print "&lt;a href = \ "" .$dir."\\".basename($file)."\"&gt;".basename($file)."&lt;/a&gt; &lt;br&gt;";
else :
print "&lt;a href = \"".$dir."/".basename($file)."\"&gt;".basename($file)."&lt;/a&gt; &lt;br&gt;";
endif:
endif; // Is_dir(file) endif: // If ! "." or ".."
endwhile;
// Закрыть каталог closedir($dh);
&lt;html &gt;
&lt;head&gt;
&lt;title&gt; &lt;? print "$page_name"; ?&gt; &lt;/title&gt;
&lt;/head&gt;
&lt;body bgcolor="#ffffff" text="#000000" link="#000000" vlink="#000000" alink="#000000"&gt;
&lt;?
// Вычислить начальный отступ
if ($using_linux == 0) :
$depth = explode("\\", $beg_path);
else :
$depth = explode("/", $beg_path);
endif:
$init_depth = sizeof($depth);
display_directory ($beg_path, $folder_location, $using_linux, $init_depth);
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>


