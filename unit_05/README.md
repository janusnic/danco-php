# danco-php
# Основы ООП

#Инкапсуляция

Инкапсуляция - это механизм, объединяющий данные и обрабатывающий их код как единое целое.
<br>
Многие преимущества ООП обусловлены одним из его фундаментальных принципов — инкапсуляцией. Инкапсуляцией называется включение различных мелких элементов в более крупный объект, в результате чего программист работает непосредственно с этим объектом. Это приводит к упрощению программы, поскольку из нее исключаются второстепенные детали.
<br>
Инкапсуляцию можно сравнить с работой автомобиля с точки зрения типичного водителя. Многие водители не разбираются в подробностях внутреннего устройства машины, но при этом управляют ею именно так, как было задумано. Пусть они не знают, как устроен двигатель, тормоз или рулевое управление, — существует специальный интерфейс, который автоматизирует и упрощает эти сложные операции. Сказанное также относится к инкапсуляции и ООП — многие подробности "внутреннего устройства" скрываются от пользователя, что позволяет ему сосредоточиться на решении конкретных задач. В ООП эта возможность обеспечивается классами, объектами и различными средствами выражения иерархических связей между ними.

# Полиморфизм

Полиморфизм позволяет использовать одни и те же имена для похожих, но технически разных задач. Главным в полиморфизме является то, что он позволяет манипулировать объектами путем создания стандартных интерфейсов для схожих действий. Полиморфизм значительно облегчает написание сложных программ.

# Наследование

Наследование позволяет одному объекту приобретать свойства другого объекта, не путайте с копированием объектов. При копировании создается точная копия объекта, а при наследовании точная копия дополняется уникальными свойствами, которые характерны только для производного объекта.

# Классы и объекты в PHP

Класс - это базовое понятие в объектно-ориентированном программировании (ООП). Классы образуют синтаксическую базу ООП. Их можно рассматривать как своего рода "контейнеры" для логически связанных данных и функций (обычно называемых методами — см. ниже). Если сказать проще, то класс - это своеобразный тип данных.
<br>
Экземпляр класса - это объект. Объект - это совокупность данных (свойств) и функций (методов) для их обработки. Свойства и методы называются членами класса. Вообще, объектом является все то, что поддерживает инкапсуляцию.
<br>
Если класс можно рассматривать как тип данных, то объект — как переменную (по аналогии). Скрипт может одновременно работать с несколькими объектами одного класса, как с несколькими переменными.
<br>
Внутри объекта данные и код (члены класса) могут быть либо открыты, либо нет. Открытые данные и члены класса являются доступными для других частей программы, которые не являются частью объекта. А вот закрытые данные и члены класса доступны только внутри этого объекта.

# Описание классов в PHP начинаются служебным словом class:
<pre>
class Имя_класса {
// описание членов класса - свойств и методов для их обработки
}
</pre>
# Для объявления объекта необходимо использовать оператор new:

Объект = new Имя_класса;
<br>
Данные описываются с помощью служебного слова var. Метод описывается так же, как и обыкновенная пользовательская функция. Методу также можно передавать параметры.
<br>
Подведем промежуточные итоги: объявление класса должно начинаться с ключевого слова class (подобно тому, как объявление функции начинается с ключевого слова function). Каждому объявлению свойства, содержащегося в классе, должно предшествовать ключевое слово var. Свойства могут относиться к любому типу данных, поддерживаемых в РНР, их можно рассматривать как переменные с небольшими различиями. После объявлений свойств следуют объявления методов, очень похожие на типичные объявления пользовательских функций.
<br>
По общепринятым правилам имена классов ООП начинаются с прописной буквы, а все слова в именах методов, кроме первого, начинаются с прописных букв (первое слово начинается со строчной буквы). Разумеется, вы можете использовать любые обозначения, которые сочтете удобными; главное — выберите стандарт и придерживайтесь его.
<br>
Пример класса на PHP:
<pre>
&lt;?php
// Создаем новый класс Coor:
class Coor {
// данные (свойства):
var $name;
var $addr;

// методы:
 function Name() {
 echo "&lt;h3&gt;John&lt;/h3&gt;";
 }

}

// Создаем объект класса Coor:
$object = new Coor;
?&gt;
</pre>
# Доступ к класам и объектам в PHP

Мы рассмотрели, каким образом описываются классы и создаются объекты. Теперь нам необходимо получить доступ к членам класса, для этого в PHP предназначен оператор -&gt;. Приведем пример:
<pre>
&lt;?php
// Создаем новый класс Coor:
class Coor {
// данные (свойства):
var $name;

// методы:
 function Getname() {
 echo "&lt;h3&gt;John&lt;/h3&gt;";
 }

}

// Создаем объект класса Coor:
$object = new Coor;
// Получаем доступ к членам класса:
$object-&gt;name = "Alex";
echo $object-&gt;name;
// Выводит 'Alex'
// А теперь получим доступ к методу класса (фактически, к функции внутри класса):
$object-&gt;Getname();
// Выводит 'John' заглавными буквами
?&gt;
</pre>
Чтобы получить доступ к членам класса внутри класса, необходимо использовать указатель $this, которы всегда относится к текущему объекту. Модифицированный метод Getname():
<pre>
function Getname() {
echo $this-&gt;name;
}
Таким же образом, можно написать метод Setname():

function Setname($name) {
$this-&gt;name = $name;
}
Теперь для изменения имени можно использовать метод Setname():

$object-&gt;Setname("Peter"); 
$object-&gt;Getname();
А вот и полный листинг кода:

&lt;?php
// Создаем новый класс Coor:
class Coor {
// данные (свойства):
var $name;

// методы:
 function Getname() {
 echo $this-&gt;name;
 }

 function Setname($name) {
 $this-&gt;name = $name;
 }

}

// Создаем объект класса Coor:
$object = new Coor;
// Теперь для изменения имени используем метод Setname():
$object-&gt;Setname("Nick");
// А для доступа, как и прежде, Getname():
$object-&gt;Getname();
// Сценарий выводит 'Nick'
?&gt;
Указатель $this можно также использовать для доступа к методам, а не только для доступа к данным:

function Setname($name) {
$this-&gt;name = $name;
$this-&gt;Getname();
}
</pre>
# Конструкторы

Довольно часто при создании объекта требуется задать значения некоторых свойств. К счастью, разработчики технологии ООП учли это обстоятельство и реализовали его в концепции конструкторов. Конструктор представляет собой метод, который задает значения некоторых свойств (а также может вызывать другие методы). Конструкторы вызываются автоматически при создании новых объектов. Чтобы это стало возможным, имя метода-конструктора должно совпадать с именем класса, в котором он содержится. Пример конструктора:
<pre>
&lt;?
class Webpage {
var $bgcolor;
 function Webpage($color) {
 $this-&gt;bgcolor = $color;
 }
}

// Вызвать конструктор класса Webpage
$page = new Webpage("brown");
?&gt;
</pre>
Раньше создание объекта и инициализация свойств выполнялись раздельно. Конструкторы позволяют выполнить эти действия за один этап.
<br>
Интересная подробность: в зависимости от количества передаваемых параметров могут вызываться разные конструкторы. В рассмотренном примере объекты класса Webpage могут создаваться двумя способами. Во-первых, вы можете вызвать конструктор, который просто создает объект, но не инициализирует его свойства:
<pre>
$page = new Webpage;
</pre>
Во-вторых, объект можно создать при помощи конструктора, определенного в классе, — в этом случае вы создаете объект класса Webpage и присваиваете значение его свойству bgcolor:

$page = new Webpage("brown");
# Деструкторы

В РНР отсутствует непосредственная поддержка деструкторов. Тем не менее, вы можете легко имитировать работу деструктора, вызывая функцию РНР unset(). Эта функция уничтожает содержимое переменной и возвращает занимаемые ею ресурсы системе. С объектами unset() работает так же, как и с переменными. Допустим, вы работаете с объектом $Webpage. После завершения работы с этим конкретным объектом вызывается функция:
<br>
unset($Webpage);
Эта команда удаляет из памяти все содержимое $Webpage. Действуя в духе инкапсуляции, можно поместить вызов unset() в метод с именем destroy() и затем вызвать его:
<br>
$Website-&gt;destroy();
Необходимость в вызове деструкторов возникает лишь при работе с объектами, использующими большой объем ресурсов, поскольку все переменные и объекты автоматически уничтожаются по завершении сценария.

# Инициализация объектов

Иногда возникает необходимость выполнить инициализацию объекта - присвоить его свойствам первоначальные значения. Предположим, имя класса Coor и он содержит два свойства:имя человека и город его проживания. Можно написать метод (функцию), который будет выполнять инициализацию объекта, например Init():
<pre>
&lt;?php
// Создаем новый класс Coor:
class Coor {
// данные (свойства):
var $name;
var $city;

// Инициализирующий метод:
 function Init($name) {
 $this-&gt;name = $name;
 $this-&gt;city = "London";
 }

}

// Создаем объект класса Coor:
$object = new Coor;
// Для инициализации объекта сразу вызываем метод:
$object-&gt;Init();
?&gt;
</pre>
Главное не забыть вызвать функцию сразу после создания объекта, либо вызвать какой-нибудь метод между созданием (оператор new) объекта и его инициализацией (вызовом Init).

Для того, чтобы PHP знал, что определенный метод нужно вызывать автоматически при создании объекта, ему нужно дать имя такое же, как и у класса (Coor):
<pre>
function Coor ($name)
$this-&gt;name = $name;
$this-&gt;city = "London";
}
</pre>
Метод, инициализирующий объект, называется конструктором. Однако, PHP не имеет деструкторов, поскольку ресурсы освобождаюся автоматически при завершении работы скриптов.

# Обращение к элементам классов

Обращение к элементам классов осуществляется с помощью оператора :: "двойное двоеточие". Используя "двойное двоеточие", можно обращаться к методам классов.

При обращении к методам классов, программист должен использовать имена этих классов.
<pre>
&lt;?php
class A {
     function example() {
         echo "Это первоначальная функция A::example().&lt;br&gt;";
     }
}

class B extends A {
     function example() {
         echo "Это переопределенная функция B::example().&lt;br&gt;";
         A::example();
     }
}

// Не нужно создавать объект класса A.
// Выводит следующее: 
// Это первоначальная функция A::example().
A::example();

// Создаем объект класса B.
$b = new B;

// Выводит следующее: 
//   Это переопределенная функция B::example().
//   Это первоначальная функция A::example().
$b-&gt;example();
?&gt;
</pre>

# Наследование классов в PHP

Наследование - это не просто создание точной копии класса, а расширение уже существующего класса, чтобы потомок мог выполнять какие-нибудь новые, характерные только ему функции.

Итак, пусть у нас есть некоторый класс A с определенными свойствами и методами. Но то, что этот класс делает, нас не совсем устраивает — например, пусть он выполняет большинство функций, по сути нам необходимых, но не реализует некоторых других. Зададимся целью создать новый класс B, как бы "расширяющий" возможности класса A, добавляющий ему несколько новых свойств и методов. Сделать это можно двумя принципиально различными способами. Первый выглядит примерно так:
<pre>
&lt;?php
class A {
  function TestA() { ... }
  function Test() { ... }
}

class B {
  var $a; // объект класса A
  function B(параметры_для_A, другие_параметры){ 
    $a = new A(параметры_для_A);
    // инициализируем другие поля B
  }
  function TestB() { ... }
  function Test() { ... }
}
?&gt;
</pre>
Поясним: в этой реализации объект класса B содержит в своем составе подобъект класса A в качестве свойства. Это свойство — лишь "частичка" объекта класса B, не более того. Подобъект не "знает", что он в действительности не самостоятелен, а содержится в классе B, поэтому не может предпринимать никаких действий, специфичных для этого класса.
<br>
Мы хотели получить расширение возможностей класса A, а не нечто, содержащее объекты A. Что означает "расширение"? Лишь одно: мы бы хотели, чтобы везде, где допустима работа с объектами класса A, была допустима и работа с объектами класса B. Но в приведенном примере это совсем не так.
<br>
Итак, мы имеем некоторые проблемы:
<br>
1. Мы не видим явно, что класс B лишь расширяет возможности A, а не является отдельной сущностью;<br>
2. Мы должны обращаться к "части A" класса B через $obj-&gt;a-&gt;TestA(), а к членам самого класса B как $obj-&gt;TestB(). Последнее может быть довольно утомительным, если, как это часто бывает, в B будет использоваться очень много методов из A и гораздо меньше — из B. Кроме того, это заставляет нас постоянно помнить о внутреннем устройстве класса B.
<br>
Теперь на практике рассмотрим, что же представляет собой наследование (или расширение возможностей) классов:
<pre>
&lt;?php
class B extends A {
  function B(параметры_для_A, другие_параметры) { 
    $this-&gt;A(параметры_для_A);
    // инициализируем другие поля B
  }

  function TestB() { ... }
  function Test() { ... }
}
?&gt;
</pre>
Ключевое слово extends говорит о том, что создаваемый класс является лишь "расширением" класса A, и не более того. То есть B содержит те же самые свойства и методы, что и A, но, помимо них и еще некоторые дополнительные, "свои".
Теперь "часть A" находится прямо внутри класса B и может быть легко доступна, наравне с методами и свойствами самого класса B. Например, для объекта $obj класса B допустимы выражения $obj-&gt;TestA() и $obj-&gt;TestB().
<br>
Итак, мы видим, что, действительно, класс B является воплощением идеи "расширение функциональности
класса A". Обратите также внимание: мы можем теперь забыть, что B унаследовал от A некоторые свойства или методы — снаружи все выглядит так, будто класс B реализует их самостоятельно.
<br>
Немного о терминологии: родительский класс A принято называть базовым классом, а класс дочерний класс B — производным от A. Иногда базовый класс также называют суперклассом, а производный — подкласcом.

Рассмотрим еще один пример на PHP:
<pre>
&lt;?php
class Parent {
  function parent_funct() { echo "&lt;h1&gt;Это родительская функция&lt;/h1&gt;"; }
  function test () { echo "&lt;h1&gt;Это родительский класс&lt;/h1&gt;"; }
}

class Child extends Parent {
  function child_funct() { echo "&lt;h2&gt;Это дочерняя функция&lt;/h2&gt;"; }
  function test () { echo "&lt;h2&gt;Это дочерний класс&lt;/h2&gt;"; }
}

$object = new Parent;
$object = new Child;

$object-&gt;parent_funct(); // Выводит 'Это родительская функция'
$object-&gt;child_funct(); // Выводит 'Это дочерняя функция'
$object-&gt;test(); // Выводит 'Это дочерний класс'
?&gt;
</pre>
Дочерний класс (подкласс) Child наследует все методы и свойства суперкласса Parent.

# Полиморфизм классов в PHP

Полиморфизм (многоформенность) является следствием идеи наследования. В общих словах, полиморфность класса — это свойство базового класса использовать функции производных классов, даже если на момент определения еще неизвестно, какой именно класс будет включать его в качестве базового и, тем самым, становиться от него производным.

Рассмотрим свойство полиморфности классов на основе следующего примера:
<pre>
&lt;?php
class A {
// Выводит, функция какого класса была вызвана
function Test() { echo "Test from A\n"; }
// Тестовая функция — просто переадресует на Test()
function Call() { Test(); }
}
class B extends A {
// Функция Test() для класса B
function Test() { echo "Test from B\n"; }
}
$a=new A();
$b=new B();
?&gt;
</pre>
Используем следующие следующие команды:
<pre>
$a-&gt;Call(); // выводит "Test from A"
$b-&gt;Test(); // выводит "Test from B"
$b-&gt;Call(); // Внимание! Выводит "Test from B"!
</pre>
Обратите внимание на последнюю строчку: вопреки ожиданиям, вызывается не функция Test() из класса A, а функция из класса B! Складывается впечатление, что Test() из B просто переопределила функцию Test() из A. Так оно на самом деле и есть. Функция, переопределяемая в производном классе, называется виртуальной.

Механизм виртуальных функций позволяет, например, "подсовывать" функциям, ожидающим объект одного класса, объект другого, производного, класса. Еще один классический пример — класс, воплощающий собой свойства геометрической фигуры, и несколько производных от него классов — квадрат, круг, треугольник и т. д.
Базовый класс имеет виртуальную функцию Draw(), которая заставляет объект нарисовать самого себя. Все производные классы-фигуры, разумеется, переопределяют эту функцию (ведь каждую фигуру нужно рисовать по-особому). Также у нас есть массив фигур, причем мы не знаем, каких именно. Зато, используя полиморфизм, мы можем, не задумываясь, перебрать все элементы массива и вызвать для каждого из них метод Draw() — фигура сама "решит", какого она типа и как ее рисовать.

А вот еще один практический пример, показывающий свойство класса - полиморфизм:
<pre>
&lt;?php
class Base {
 function funct() {
 echo "&lt;h2&gt;Функция базового класса&lt;/h2&gt;";
 }
 function base_funct() {
 $this-&gt;funct();
 }
}

class Derivative extends Base {
 function funct() {
 echo "&lt;h3&gt;Функция производного класса&lt;/h3&gt;";
 }
}

$b = new Base();
$d = new Derivative();

$b-&gt;base_funct();
$d-&gt;funct();
$d-&gt;base_funct();
// Скрипт выводит:

// Функция базового класса
// Функция производного класса
// Функция производного класса
?&gt;
</pre>
В рассмотренном примере функция base_funct() класса Base была перезаписана одноименной функцией класса Derivative.

# Работа с объектами классов PHP

# Копирование объектов

Так уж устроен PHP, что в нем все переменные, в том числе и объекты, всегда рассматриваются как простой набор значений и копируются целиком. Например, если у нас есть объект $a и мы выполняем оператор $b=$a, то все содержимое $a будет скопировано в $b один-в-один.
<pre>
&lt;?php
class A {
// Создаем новый метод:
 function Test() {
 echo "&lt;h1&gt;Hello!&lt;/h1&gt;";
 }
}
// Создаем объект класса A:
$a=new A();
// Копируем объект $a:
$b=$a;
// Теперь работаем с новым объектом $b
$b-&gt;Test(); // Выводит 'Hello!'
?&gt;
</pre>
# Сравнение объектов

В PHP 4 объекты сравниваются очень просто: по именам. Два объекта равны, если они имеют те же самые свойства и значения, а также являются экземплярами одного и того же класса. Сравнение двух объектов осуществляют, используя оператор эквивалентности (===). Вот пример:
<pre>
&lt;?php
class A {
// Создаем новый метод:
 function Test() {
 echo "&lt;h1&gt;Hello!&lt;/h1&gt;";
 }
}

// Создаем объект класса A:
$a=new A();
// Создаем объект класса A:
$b=new A();
// Выводит 'Объекты равны':
if ($a===$b) echo "&lt;h3&gt;Объекты равны&lt;/h2&gt;";
?&gt;
</pre>
# Ссылки на объект

PHP позволяет создавать ссылки на объекты. Вот пример:
<pre>
&lt;?php
class A {
// Создаем новый метод:
 function Test() {
 echo "&lt;h1&gt;Hello!&lt;/h1&gt;";
 }
}

// Создаем объект класса A:
$a=new A();
// Ссылка на объект класса A:
$b=& new A();
$b-&gt;Test();
?&gt;
</pre>


# PHP5 и ООП

В PHP 5 объектная модель была полностью переписана для того, чтобы сразу работать с указателями на объект. Если вы явно не клонируете объект, используя ключевое слово clone, вы никогда не будете работать с копией объекта, думая, что работаете с самим объектом. В PHP 5 уже не нужно явно передавать объекты или присваивать их по ссылке, это делается автоматически.

<br>
public/private/protected - модификаторы доступа для методов и свойств
Позволяют управлять доступом к методам и свойствам. Теперь видимость свойств и методов может быть определена ключевыми словами: public, private, protected. Модификатор public позволяет обращаться к свойствам и методам отовсюду. Модификатор private позволяет обращаться к свойствам и методам только внутри текущего класса. Модификатор protected позволяет обращаться к свойствам и методам только текущего класса и класса, который наследует свойства и методы текущего класса.
<pre>
&lt;?php
/**
  * Define MyClass
  */
class MyClass
{
     public $public = 'Public';
     protected $protected = 'Protected';
     private $private = 'Private';

     function printHello()
     {
         echo $this-&gt;public;
         echo $this-&gt;protected;
         echo $this-&gt;private;
     }
}

$obj = new MyClass();
echo $obj-&gt;public; // Works
echo $obj-&gt;protected; // Fatal Error
echo $obj-&gt;private; // Fatal Error
$obj-&gt;printHello(); // Shows Public, Protected and Private


/**
  * Define MyClass2
  */
class MyClass2 extends MyClass
{
     // We can redeclare the public and protected method, but not private
     protected $protected = 'Protected2';

     function printHello()
     {
         echo $this-&gt;public;
         echo $this-&gt;protected;
         echo $this-&gt;private;
     }
}

$obj2 = new MyClass2();
echo $obj-&gt;public; // Works
echo $obj2-&gt;private; // Undefined
echo $obj2-&gt;protected; // Fatal Error
$obj2-&gt;printHello(); // Shows Public, Protected2, not Private

?&gt;
</pre>
# Унифицированный конструктор __construct()
PHP 5 позволяет объявлять методы-конструкторы. Классы, в которых объявлен метод-констуктор, будут вызывать этот метод при каждом создании нового объекта, так что это может оказаться полезным, чтобы, например, инициализировать какое-либо состояние объекта перед его использованием. Конструктор, ранее совпадавший с названием класса, теперь необходимо объявлять как __construct(), что позволит легче перемещать классы в иерархиях. Конструкторы в классах-родителях не вызываются автоматически. Чтобы вызвать конструктор, объявленный в родительском классе, следует обратиться к методу parent::__construct().
<pre>
&lt;?php
class BaseClass {
     function __construct() {
         print "Конструктор класса BaseClass\n";
     }
}

class SubClass extends BaseClass {
     function __construct() {
         parent::__construct();
         print "Конструктор класса SubClass\n";
     }
}

$obj = new BaseClass();
$obj = new SubClass();
?&gt;
</pre>
Если PHP 5 не может обнаружить объявленный метод __construct(), вызов конструктора произойдет по прежней схеме, через обращение к методу, имя которого соответствует имени класса. Может возникнуть только одна проблема совместимости старого кода, если в нём присутствуют классы с методами __construct().

Поддержка деструктора для класса, определяемого как метод __destructor()
PHP 5 предоставляет концепцию деструкторов, сходную с теми, что применяются в других ОО языках, таких, как Java: когда освобождается последняя ссылка на объект, перед высвобождением памяти, занимаемой этим объектом, вызывается метод __destruct(), не принимающий параметров.
<pre>
&lt;?php
class MyDestructableClass {
     function __construct() {
         print "Конструктор\n";
         $this-&gt;name = "MyDestructableClass";
     }

     function __destruct() {
         print "Уничтожается " . $this-&gt;name . "\n";
     }
}

$obj = new MyDestructableClass();
?&gt;
</pre>
Как и в случае с конструкторами, деструкторы, объявленные в родительском классе, не будут вызваны автоматически. Для вызова деструктора, объявленном в классе-родителе, следует обратиться к методу parent::__destruct().